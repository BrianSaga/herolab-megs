<?xml version="1.0" encoding="ISO-8859-1"?>

<!-- This file contains the definition of the "Basics" tab panel. This tab is where
      the user configures that attributes and skills of the character.

      All public visual elements used with this tab panel start with the prefix "ba"
      to associate them with the tab.
-->

<document signature="Hero Lab Data">


  <!-- baAttrib portal
        Presents a fixed table that consists of the various attributes for the
        character. The "explicit" sortset is used to enforce a hand-numbered
        ordering of the attributes. Since the full list is short enough to always
        be visible, the table has no scroller.

        We use a "headertitle" script to place a suitable title above the table.
  -->
  <portal
    id="baActing"
    style="tblInvis">
    <table_fixed
      component="Attribute"
      showtemplate="baAttrPick"
      showsortset="explicit"
      scrollable="no">
	  <list>AttrType.ActOpp</list>
      <headertitle><![CDATA[
        @text = "Acting/Opposing"
        ]]></headertitle>
      </table_fixed>
    </portal>
	
	<portal
    id="baEffect"
    style="tblInvis">
    <table_fixed
      component="Attribute"
      showtemplate="baAttrPick"
      showsortset="explicit"
      scrollable="no">
	  <list>AttrType.Effect</list>	  
      <headertitle><![CDATA[
        @text = "Effect"
        ]]></headertitle>
      </table_fixed>
    </portal>
	
	<portal
    id="baResist"
    style="tblInvis">
    <table_fixed
      component="Attribute"
      showtemplate="baAttrPick"
      showsortset="explicit"
      scrollable="no">
	  <list>AttrType.Resistance</list>	  
      <headertitle><![CDATA[
        @text = "Resistance"
        ]]></headertitle>
      </table_fixed>
    </portal>

	<portal
    id="baWealth"
    style="tblInvis">
    <table_fixed
      component="Attribute"
      showtemplate="baAttrPick"
      showsortset="explicit"
      scrollable="no">
	  <list>thingid.attrWealth</list>	  
      </table_fixed>
    </portal>


  <!-- baSkill portal
        Presents a fixed table consisting of all skills for the character, which
        are shown in alphabetical order (the default). The full list will fit, so
        no scroller is needed.

        We use a "headertitle" script to place a suitable title above the table.
  -->
  <portal
    id="baSkill"
    style="tblInvis">
    <table_fixed
      component="Skill"
      showtemplate="baSklPick"
      scrollable="no">
      <headertitle><![CDATA[
        @text = "Skills"
        ]]></headertitle>
      </table_fixed>
    </portal>


  <!-- baTrait portal
        Presents a fixed table with all derived traits in it. The sortset allows
        us to dictate the order of display via a hand-numbered sequence. All traits
        are always visible, so we don't need a scroller.
  -->
  <portal
    id="baTrait"
    style="tblInvis">
    <table_fixed
      component="Derived"
      showtemplate="baTrtPick"
      showsortset="explicit"
      scrollable="no">
      </table_fixed>
    </portal>

	
  <!-- baAdvantages portal
        Presents a fixed table consisting of all advantages for the character, which
        are shown in alphabetical order (the default). The full list will fit, so
        no scroller is needed.

        We use a "headertitle" script to place a suitable title above the table.
  -->
  <portal
    id="baAdvant"
    style="tblInvis">
    <table_dynamic
      component="Advantage"
      showtemplate="baAdvPick"
      choosetemplate="baAdvCh"
	  showfixedlast="yes"
      scrollable="yes">
      <headertitle><![CDATA[
        @text = "Advantages"
        ]]></headertitle>
      <additem><![CDATA[
        ~if we're in advancement mode, we've been frozen, so display accordingly
        if (state.iscreate = 0) then
          @text = "{text clrgrey}Add Advantages Via Advances Tab"
          done
          endif

        ~set the color based on whether the proper number of slots are allocated
        if (#resleft[resHP] = 0) then
          @text = "{text clrgrey}"
        elseif (#resleft[resHP] < 0) then
          @text = "{text clrwarning}"
          endif
        @text &= "Add New Advantage"
        ]]></additem>		
      </table_dynamic>
    </portal>


	<!-- baDrawbacks portal
        Presents a fixed table consisting of all drawbacks for the character, which
        are shown in alphabetical order (the default). The full list will fit, so
        no scroller is needed.

        We use a "headertitle" script to place a suitable title above the table.
  -->
  <portal
    id="baDraw"
    style="tblInvis">
    <table_dynamic
      component="Drawback"
      showtemplate="baDrawPick"
      choosetemplate="baDrawCh"
      showfixedlast="yes"
      scrollable="yes">
      <headertitle><![CDATA[
        @text = "Drawbacks"
        ]]></headertitle>
      <additem><![CDATA[
        ~if we're in advancement mode, we've been frozen, so display accordingly
        if (state.iscreate = 0) then
          @text = "{text clrgrey}Add Drawbacks Via Advances Tab"
          done
          endif

        ~set the color based on whether the proper number of slots are allocated
        if (#resleft[resHP] = 0) then
          @text = "{text clrgrey}"
        elseif (#resleft[resHP] < 0) then
          @text = "{text clrwarning}"
          endif
        @text &= "Add New Drawback"
        ]]></additem>
	</table_dynamic>
    </portal>	
	
  <!-- baAttrPick template
        Displays one attribute within the table of attributes. We setup suitable
        margins around each template, which provides substantial spacing between
        each item and the edges of the table. Each attribute consists of its name,
        an incrementer where the user can assign the value, and an info button that
        provides details on the attribute when the user moves the mouse over it.
  -->
  <template
    id="baAttrPick"
    name="Attribute Pick"
    compset="Attribute"
    marginhorz="5"
    marginvert="9">

    <portal
      id="name"
      style="lblNormal"
      showinvalid="yes">
      <label>
		<labeltext><![CDATA[
			if (field[attItalic].value <> 0) then
				@text = "{i}" & field[trtAbbrev].text & "{/i}"
			else
				@text = field[trtAbbrev].text
			endif
		]]></labeltext>
        </label>
      </portal>

    <portal
      id="value"
      style="incrSimple">
      <incrementer
        field="trtUser">
        </incrementer>
      <mouseinfo><![CDATA[
        if (hero.tagis[mode.creation] = 0) then
          @text = "Attributes must be modified via the Advances tab once the character is locked for play."
        elseif (autonomous = 0) then
          @text = "This trait has been improved via the Advances tab and cannot be modified further from here."
        else
          @text = "Allocate points to this attribute by clicking on the arrows to increase/decrease the number of points assigned."
          endif
        ]]></mouseinfo>
      </portal>

	  <portal
      id="total"
      style="lblXLarge"
      showinvalid="yes">
      <label
        field="trtFinal">
        </label>
      </portal> 
	  
    <portal
      id="ital"
      style="chkSmall"
      tiptext="Check this option if attribute is italicized">
      <checkbox
        field="attItalic"
        message="">
        </checkbox>
      </portal>		  

    <portal
      id="info"
      style="actInfo">
      <action
        action="info">
        </action>
      </portal>
	  
    <portal
      id="delete"
      style="actDelete"
      tiptext="Click to delete this item">
      <action
        action="delete">
        </action>
      </portal>	  

    <position><![CDATA[
      ~set up our height based on our tallest portal
      height = portal[info].height

      ~if this is a "sizing" calculation, we're done
      doneif (issizing <> 0)

      ~freeze our value in advancement mode or if an advancement has modified us
      ~Note: All freezing must be done *before* any positioning is performed.
      if (state.iscreate = 0) then
        portal[value].freeze = 1
      elseif (autonomous = 0) then
        portal[value].freeze = 1
        endif

      ~position our tallest portal at the top
      portal[info].top = 0

      ~center the other portals vertically
      perform portal[name].centervert
      perform portal[value].centervert
      perform portal[total].centervert
      perform portal[ital].centervert

      ~position the info portal on the far right
      if (container.ishero <> 0) then
		perform portal[info].alignedge[right,-5]
		portal[delete].visible = 0
	  else
	  	perform portal[delete].alignedge[right,-5]
	  	perform portal[info].alignrel[rtol,delete,-5]
		portal[delete].visible = 1
	  endif
	  
     ~position the incrementer to the left of the info portal (plus a gap)
      perform portal[total].alignrel[rtol,info,-5]
      perform portal[value].alignrel[rtol,total,-5]

      ~position the checkbox to the left of the info portal (plus a gap)
      portal[ital].left = 0
	  if (container.ishero <> 0) then
		portal[ital].visible = 0
	  endif	  
	  
      ~position the name on the left and make sure its width does not exceed the available space
      portal[name].left = portal[ital].right + 1
      portal[name].width = minimum(portal[name].width,portal[value].left - portal[name].left - 1)
      ]]></position>

    </template>

	<!-- baDrawPick template
        Displays one attribute within the table of attributes. We setup suitable
        margins around each template, which provides substantial spacing between
        each item and the edges of the table. Each attribute consists of its name,
        an incrementer where the user can assign the value, and an info button that
        provides details on the attribute when the user moves the mouse over it.
  -->
  <template
    id="baDrawPick"
    name="Drawback Pick"
    compset="Drawback"
    marginhorz="13"
    marginvert="9">

    <portal
      id="name"
      style="lblNormal"
      showinvalid="yes">
      <label
        field="thingname">
        </label>
      </portal>

    <portal
      id="lblmenu1"
      style="lblSecond">
      <label
        field="usrLabel1">
        </label>
      </portal>

    <portal
      id="lblmenu2"
      style="lblSecond">
      <label
        field="usrLabel2">
        </label>
      </portal>

    <portal
      id="menu1"
      style="menuNormal">
      <menu_things
        field="usrChosen1"
        component="none"
        maxvisible="10"
        usepicksfield="usrSource1"
        candidatefield="usrCandid1">
        </menu_things>
      </portal>

    <portal
      id="menu2"
      style="menuNormal">
      <menu_things
        field="usrChosen2"
        component="none"
        maxvisible="10"
        usepicksfield="usrSource2"
        candidatefield="usrCandid2">
        </menu_things>
      </portal>

    <portal
      id="lblmenuar"
      style="lblSecond">
      <label
        field="usrLabelAr">
        </label>
      </portal>

    <portal
      id="menuarray"
      style="menuNormal">
      <menu_array
        field="usrSelect"
        array="usrArray"
        maxvisible="10">
        </menu_array>
      </portal>

    <portal
      id="checkbox"
      style="chkNormal">
      <checkbox
        field="usrIsCheck"
        dynamicfield="usrChkText">
        </checkbox>
      </portal>

    <portal
      id="info"
      style="actInfo">
      <action
        action="info">
        </action>
      <mouseinfo/>
      </portal>

    <portal
      id="delete"
      style="actDelete"
      tiptext="Click to delete this item">
      <action
        action="delete">
        </action>
      </portal>
	  
	<portal
      id="cost"
      style="lblSecond">
      <label>
        <labeltext><![CDATA[
			var cost as number
			cost = tagvalue[HPCost.?]
			@text = "-" & cost
		]]></labeltext>
        </label>
      </portal>
	  
    <portal
      id="domain"
      style="editNormal">
      <edit
        field="domDomain"
		placeholdertext="Details">
        </edit>
      </portal>	 	  
	  
    <position><![CDATA[
     ~set up our height based on our tallest portal
      height = portal[info].height

      ~if this is a "sizing" calculation, we're done
      doneif (issizing <> 0)

      ~position our tallest portal at the top
      portal[info].top = 0

      ~center the other portals vertically
      perform portal[name].centervert
      perform portal[delete].centervert
      perform portal[lblmenu1].centervert
      perform portal[menu1].centervert
      perform portal[lblmenu2].centervert
      perform portal[menu2].centervert
      perform portal[lblmenuar].centervert
      perform portal[menuarray].centervert
      perform portal[checkbox].centervert
      perform portal[domain].centervert

      ~determine whether our portals are visible; we only show them if requested
      ~Note: Remember that a non-empty tagexpr field indicates menu selection is used.
      if (field[usrCandid1].isempty <> 0) then
        portal[lblmenu1].visible = 0
        portal[menu1].visible = 0
      elseif (field[usrLabel1].isempty <> 0) then
        portal[lblmenu1].visible = 0
        endif
      if (field[usrCandid2].isempty <> 0) then
        portal[lblmenu2].visible = 0
        portal[menu2].visible = 0
      elseif (field[usrLabel2].isempty <> 0) then
        portal[lblmenu2].visible = 0
        endif
      if (empty(field[usrArray].arraytext[0]) <> 0) then
        portal[lblmenuar].visible = 0
        portal[menuarray].visible = 0
      elseif (field[usrLabelAr].isempty <> 0) then
        portal[lblmenuar].visible = 0
        endif
      if (field[usrChkText].isempty <> 0) then
        portal[checkbox].visible = 0
        endif

      ~position the delete portal on the far right and the info portal next to it
      perform portal[delete].alignedge[right,0]
      perform portal[info].alignrel[rtol,delete,-8]
      perform portal[cost].alignrel[rtol,info,-8]

      ~determine our effective right edge, allowing for the buttons above
      var edge as number
      edge = portal[cost].left - 8

      ~setup the default portal width and gap to be used between and around portals
      var defwidth as number
      var gap as number
      defwidth = 100
      gap = 10

	  
      ~determine the minimum amount of space we need to reserve for our portals
      var reserve as number
      if (portal[checkbox].visible <> 0) then
        reserve = defwidth
      elseif (portal[menuarray].visible <> 0) then
        reserve = portal[lblmenuar].width * portal[lblmenuar].visible
        reserve += defwidth + gap
      elseif (portal[menu1].visible <> 0) then
        reserve = portal[lblmenu1].width * portal[lblmenu1].visible
        reserve += defwidth + gap
        reserve += portal[lblmenu2].width * portal[menu2].visible
        reserve += (defwidth + gap) * portal[menu2].visible
        endif

      ~position the name on the left, reserving our minimum space for any portals
      var x as number
      portal[name].left = 0
      portal[name].width = minimum(portal[name].width,edge - portal[name].left - reserve)
      x = portal[name].right + gap

      ~setup the maximum width for our some portals, regardless of space available
      var maxwidth as number
      maxwidth = 150


	  ~if we don't need a domain, hide it
      if (tagis[User.NeedDomain] = 0) then
        portal[domain].visible = 0	
	        ~otherwise, position the domain portals next to the name
			~RDS altered to make the name portal invivisible and shift the domain to the name position 
			~    to use it as a custom Skill name when a Custom Skill is chosen
      else
		portal[domain].left = x 
		portal[domain].width = minimum(125,portal[cost].left - portal[domain].left - 5)
		x = portal[domain].right + 5
	  endif		
	  	  	  
	  
      ~if we have a checkbox, size and position it appropriately
      if (portal[checkbox].visible <> 0) then
        portal[checkbox].left = x

      ~if we have an array-based menu, size and position it appropriately
      elseif (portal[menuarray].visible <> 0) then
        if (portal[lblmenuar].visible <> 0) then
          portal[lblmenuar].left = x
          x = portal[lblmenuar].right + 4
          endif
        portal[menuarray].left = x
        portal[menuarray].width = maxwidth

      ~if we have one thing-based menu, size and position it appropriately
      elseif (portal[menu1].visible + portal[menu2].visible = 1) then
        if (portal[lblmenu1].visible <> 0) then
          portal[lblmenu1].left = x
          x = portal[lblmenu1].right + 4
          endif
        portal[menu1].left = x
        portal[menu1].width = minimum(edge - portal[menu1].left,maxwidth)

      ~if we have two thing-based menus, size and position them appropriately
      elseif (portal[menu1].visible <> 0) then
        if (portal[lblmenu1].visible <> 0) then
          portal[lblmenu1].left = x
          x = portal[lblmenu1].right + 4
          endif
        portal[menu1].left = x
        var extra as number
        extra = (portal[lblmenu2].width + 4) * portal[lblmenu2].visible
        var actual as number
        actual = (edge - portal[menu1].left - extra - gap) / 2
        portal[menu1].width = minimum(actual,maxwidth)
        portal[menu2].width = portal[menu1].width
        x = portal[menu1].right + gap
        if (portal[lblmenu2].visible <> 0) then
          portal[lblmenu2].left = x
          x = portal[lblmenu2].right + 4
          endif
        portal[menu2].left = x
        endif


      ~if a menu is visible, make sure it has a selection
      if (portal[menu1].visible <> 0) then
        if (field[usrChosen1].ischosen = 0) then
          perform portal[menu1].setstyle[menuError]
          endif
        endif
      if (portal[menu2].visible <> 0) then
        if (field[usrChosen2].ischosen = 0) then
          perform portal[menu2].setstyle[menuError]
          endif
        endif
      if (portal[menuarray].visible <> 0) then
        if (field[usrSelect].isempty <> 0) then
          perform portal[menuarray].setstyle[menuError]
          endif
        endif
      ]]></position>
    </template>
	
	
  <template
    id="baAdvPick"
    name="Advantage Pick"
    compset="Advantage"
    marginhorz="3"
    marginvert="2">
	
    <portal
      id="name"
      style="lblNormal"
      showinvalid="yes">
      <label
        field="thingname">
        </label>
      </portal>

    <portal
      id="lblmenu1"
      style="lblSecond">
      <label
        field="usrLabel1">
        </label>
      </portal>

    <portal
      id="lblmenu2"
      style="lblSecond">
      <label
        field="usrLabel2">
        </label>
      </portal>

    <portal
      id="menu1"
      style="menuNormal">
      <menu_things
        field="usrChosen1"
        component="none"
        maxvisible="10"
        usepicksfield="usrSource1"
        candidatefield="usrCandid1">
        </menu_things>
      </portal>

    <portal
      id="menu2"
      style="menuNormal">
      <menu_things
        field="usrChosen2"
        component="none"
        maxvisible="10"
        usepicksfield="usrSource2"
        candidatefield="usrCandid2">
        </menu_things>
      </portal>

    <portal
      id="lblmenuar"
      style="lblSecond">
      <label
        field="usrLabelAr">
        </label>
      </portal>

    <portal
      id="menuarray"
      style="menuNormal">
      <menu_array
        field="usrSelect"
        array="usrArray"
        maxvisible="10">
        </menu_array>
      </portal>

    <portal
      id="checkbox"
      style="chkNormal">
      <checkbox
        field="usrIsCheck"
        dynamicfield="usrChkText">
        </checkbox>
      </portal>

    <portal
      id="info"
      style="actInfo">
      <action
        action="info">
        </action>
      <mouseinfo/>
      </portal>

    <portal
      id="delete"
      style="actDelete"
      tiptext="Click to delete this item">
      <action
        action="delete">
        </action>
      </portal>
	  
    <portal
      id="cost"
      style="lblSecond">
      <label>
        <labeltext><![CDATA[
			@text = tagvalue[HPCost.?]
		]]></labeltext>
        </label>
      </portal>	

    <portal
      id="domain"
      style="editNormal">
      <edit
        field="domDomain"
		placeholdertext="Details">
        </edit>
      </portal>	 	  
  	  
    <position><![CDATA[
      ~set up our height based on our tallest portal
      height = portal[info].height

      ~if this is a "sizing" calculation, we're done
      doneif (issizing <> 0)

      ~position our tallest portal at the top
      portal[info].top = 0

      ~center the other portals vertically
      perform portal[name].centervert
      perform portal[delete].centervert
      perform portal[lblmenu1].centervert
      perform portal[menu1].centervert
      perform portal[lblmenu2].centervert
      perform portal[menu2].centervert
      perform portal[lblmenuar].centervert
      perform portal[menuarray].centervert
      perform portal[checkbox].centervert
      perform portal[domain].centervert

      ~determine whether our portals are visible; we only show them if requested
      ~Note: Remember that a non-empty tagexpr field indicates menu selection is used.
      if (field[usrCandid1].isempty <> 0) then
        portal[lblmenu1].visible = 0
        portal[menu1].visible = 0
      elseif (field[usrLabel1].isempty <> 0) then
        portal[lblmenu1].visible = 0
        endif
      if (field[usrCandid2].isempty <> 0) then
        portal[lblmenu2].visible = 0
        portal[menu2].visible = 0
      elseif (field[usrLabel2].isempty <> 0) then
        portal[lblmenu2].visible = 0
        endif
      if (empty(field[usrArray].arraytext[0]) <> 0) then
        portal[lblmenuar].visible = 0
        portal[menuarray].visible = 0
      elseif (field[usrLabelAr].isempty <> 0) then
        portal[lblmenuar].visible = 0
        endif
      if (field[usrChkText].isempty <> 0) then
        portal[checkbox].visible = 0
        endif

      ~position the delete portal on the far right and the info portal next to it
      perform portal[delete].alignedge[right,0]
      perform portal[info].alignrel[rtol,delete,-8]
      perform portal[cost].alignrel[rtol,info,-8]

      ~determine our effective right edge, allowing for the buttons above
      var edge as number
      edge = portal[info].left - 8

      ~setup the default portal width and gap to be used between and around portals
      var defwidth as number
      var gap as number
      defwidth = 100
      gap = 10

      ~determine the minimum amount of space we need to reserve for our portals
      var reserve as number
      if (portal[checkbox].visible <> 0) then
        reserve = defwidth
      elseif (portal[menuarray].visible <> 0) then
        reserve = portal[lblmenuar].width * portal[lblmenuar].visible
        reserve += defwidth + gap
      elseif (portal[menu1].visible <> 0) then
        reserve = portal[lblmenu1].width * portal[lblmenu1].visible
        reserve += defwidth + gap
        reserve += portal[lblmenu2].width * portal[menu2].visible
        reserve += (defwidth + gap) * portal[menu2].visible
        endif

      ~position the name on the left, reserving our minimum space for any portals
      var x as number
      portal[name].left = 0
      portal[name].width = minimum(portal[name].width,edge - portal[name].left - reserve)
      x = portal[name].right + gap

      ~setup the maximum width for our some portals, regardless of space available
      var maxwidth as number
      maxwidth = 150

      ~if we have a checkbox, size and position it appropriately
      if (portal[checkbox].visible <> 0) then
        portal[checkbox].left = x

      ~if we have an array-based menu, size and position it appropriately
      elseif (portal[menuarray].visible <> 0) then
        if (portal[lblmenuar].visible <> 0) then
          portal[lblmenuar].left = x
          x = portal[lblmenuar].right + 4
          endif
        portal[menuarray].left = x
        portal[menuarray].width = maxwidth

      ~if we have one thing-based menu, size and position it appropriately
      elseif (portal[menu1].visible + portal[menu2].visible = 1) then
        if (portal[lblmenu1].visible <> 0) then
          portal[lblmenu1].left = x
          x = portal[lblmenu1].right + 4
          endif
        portal[menu1].left = x
        portal[menu1].width = minimum(edge - portal[menu1].left,maxwidth)

      ~if we have two thing-based menus, size and position them appropriately
      elseif (portal[menu1].visible <> 0) then
        if (portal[lblmenu1].visible <> 0) then
          portal[lblmenu1].left = x
          x = portal[lblmenu1].right + 4
          endif
        portal[menu1].left = x
        var extra as number
        extra = (portal[lblmenu2].width + 4) * portal[lblmenu2].visible
        var actual as number
        actual = (edge - portal[menu1].left - extra - gap) / 2
        portal[menu1].width = minimum(actual,maxwidth)
        portal[menu2].width = portal[menu1].width
        x = portal[menu1].right + gap
        if (portal[lblmenu2].visible <> 0) then
          portal[lblmenu2].left = x
          x = portal[lblmenu2].right + 4
          endif
        portal[menu2].left = x
        endif
		
	  ~if we don't need a domain, hide it
      if (tagis[User.NeedDomain] = 0) then
        portal[domain].visible = 0	
	        ~otherwise, position the domain portals next to the TL
			~RDS altered to make the name portal invivisible and shift the domain to the name position 
			~    to use it as a custom Skill name when a Custom Skill is chosen
      else
		portal[domain].left = x 
		portal[domain].width = minimum(190,portal[info].left - portal[domain].left - 5)		 
	  endif				

      ~if a menu is visible, make sure it has a selection
      if (portal[menu1].visible <> 0) then
        if (field[usrChosen1].ischosen = 0) then
          perform portal[menu1].setstyle[menuError]
          endif
        endif
      if (portal[menu2].visible <> 0) then
        if (field[usrChosen2].ischosen = 0) then
          perform portal[menu2].setstyle[menuError]
          endif
        endif
      if (portal[menuarray].visible <> 0) then
        if (field[usrSelect].isempty <> 0) then
          perform portal[menuarray].setstyle[menuError]
          endif
        endif
      ]]></position>

    </template>

	<template
    id="baDrawCh"
    name="Drawback Choice"
    compset="Drawback"
    marginhorz="13"
    marginvert="9">

    <portal
      id="name"
      style="lblNormal"
      showinvalid="yes">
      <label
        field="name">
        </label>
      </portal>

    <portal
      id="cost"
      style="lblSecond">
      <label>
        <labeltext><![CDATA[
			@text = "-" & tagvalue[HPCost.?]
		]]></labeltext>
        </label>
      </portal>
	  	  
    <position><![CDATA[
      ~set up our height based on our tallest portal
	 height = portal[name].height
	 
	   
      ~if this is a "sizing" calculation, we're done
      doneif (issizing <> 0)

      ~position the other portals vertically
      perform portal[name].centervert
      perform portal[cost].centervert
	  

      ~position the cost portal to the left of the info button
      perform portal[cost].alignedge[right,-2]

      ~position the name on the left
      portal[name].left = 0


      ]]></position>

    </template>

	<template
    id="baAdvCh"
    name="Advantage Choice"
    compset="Advantage"
    marginhorz="13"
    marginvert="9">

    <portal
      id="name"
      style="lblNormal"
      showinvalid="yes">
      <label
        field="name">
        </label>
      </portal>

    <portal
      id="cost"
      style="lblSecond">
      <label>
        <labeltext><![CDATA[
			@text = tagvalue[HPCost.?]
		]]></labeltext>
        </label>
      </portal>
	  	  
    <position><![CDATA[
      ~set up our height based on our tallest portal
	 height = portal[name].height
	 
	   
      ~if this is a "sizing" calculation, we're done
      doneif (issizing <> 0)

      ~position the other portals vertically
      perform portal[name].centervert
      perform portal[cost].centervert
	  

      ~position the cost portal to the left of the info button
      perform portal[cost].alignedge[right,-2]

      ~position the name on the left
      ~position the name on the left
      portal[name].left = 0


      ]]></position>

    </template>

  <!-- baTrtPick template
        Displays one trait within the table of traits. The trait name is shown on
        the left, with appropriate details about the derived value on the right.
        At the right edge is an info button that can be moused over for more info.
        As with the other templates above, we use the margins to establish good
        visual spacing between and around the items in the table.
  -->
  <template
    id="baTrtPick"
    name="Trait Pick"
    compset="Trait"
    marginhorz="16"
    marginvert="9">

    <portal
      id="name"
      style="lblLeft"
      showinvalid="yes">
      <label>
        <labeltext><![CDATA[
          @text = field[name].text & ":"
          ]]></labeltext>
        </label>
      </portal>

    <portal
      id="details"
      style="lblLeft">
      <label>
        <labeltext><![CDATA[
          @text = field[trtFinal].text
          ]]></labeltext>
        </label>
      <mouseinfo><![CDATA[
        ~insert appropriate code to explain how the trait was derived
        @text = "???"
        ]]></mouseinfo>
      </portal>

    <portal
      id="info"
      style="actInfo">
      <action
        action="info">
        </action>
      </portal>

    <position><![CDATA[
      ~set up our height based on our tallest portal
      height = portal[info].height

      ~if this is a "sizing" calculation, we're done
      doneif (issizing <> 0)

      ~position our tallest portal at the top
      portal[info].top = 0

      ~center the other portals vertically
      perform portal[name].centervert
      perform portal[details].centervert

      ~position the info portal on the far right
      perform portal[info].alignedge[right,0]

      ~position the name on the left and give it some reasonable space
      portal[name].left = 0
      portal[name].width = 65

      ~position the details to the right of the name and the left of the info portal
      perform portal[details].alignrel[ltor,name,10]
      portal[details].width = portal[info].left - portal[details].left - 10
      ]]></position>

    </template>


  <!-- basics layout
        This layout orchestrates the display of all various visual elements that
        comprise the Basics tab. We have titles above the attributes and skills,
        the attributes and skills tables themselves, a horizontal separator, and
        the table of derived traits.

        Each of these portals and templates is identified as a "reference" by the
        layout. Using references allows distinct instances of portals and templates
        to be re-used within multiple layouts. You can even use the same template
        multiple times within a single layout.

        The visual elements used in the layout are all sized and positioned via
        the "position" script. This script is invoked to setup the dimensions of
        visual elements and trigger the positioning of the contents of those
        elements via the "render" invocation.

        The tab order between items is controlled via the optional "taborder" XML
        attribute on the various portal and template references. Within a template,
        the tab order is dictated by the order the portals are listed within the
        XML. Within a table, the tab order is dictated by the item sequence. The
        "taborder" attribute coordinates the relative sequence of portals and
        templates within the layout. In this layout, the tab order will move down
        the left column and then shift over to the right column.
  -->
  <layout
    id="basics">
    <portalref portal="baActing" taborder="10"/>
    <portalref portal="baEffect" taborder="20"/>
    <portalref portal="baResist" taborder="30"/>
    <portalref portal="baWealth" taborder="40"/>
    <portalref portal="baTrait" taborder="50"/>
    <portalref portal="baAdvant" taborder="60"/>
    <portalref portal="baDraw" taborder="70"/>
    <portalref portal="Horizontal"/>

    <!-- This script sizes and positions the layout and its child visual elements. -->
    <position><![CDATA[
      ~size and position the attributes table in the top left; we set the height to
      ~the full layout height, but the table will only use the space it needs
      portal[baActing].width = width / 3
      portal[baActing].left = 0
      portal[baActing].height = height
	  
	  portal[baEffect].width = width / 3
      portal[baEffect].left = portal[baActing].right + 5
      portal[baActing].height = height
	  
	  portal[baResist].width = width / 3
      portal[baResist].left = portal[baEffect].right + 5
      portal[baResist].height = height	  

      ~set the separator width and position it beneath the attributes
      portal[Horizontal].width = width - 5
      portal[Horizontal].top = portal[baActing].bottom + 15
      portal[Horizontal].left = portal[baActing].left
	  
      ~size and position the traits table beneath the separator; we set the height
      ~the the full layout height, but the table will only use the space it needs
      portal[baTrait].width = portal[baActing].width
      portal[baTrait].left = portal[baActing].left
      portal[baTrait].top = portal[Horizontal].bottom + 5
      portal[baTrait].height = height - portal[baTrait].top

      ~size and position the traits table beneath the separator; we set the height
      ~the the full layout height, but the table will only use the space it needs
      portal[baWealth].width = portal[baResist].width
      portal[baWealth].left = portal[baResist].left
      portal[baWealth].top = portal[Horizontal].bottom + 5
      portal[baWealth].height = height - portal[baWealth].top

      portal[baAdvant].width = width
      portal[baAdvant].left = portal[baActing].left
      portal[baAdvant].top = portal[baTrait].bottom + 5
      portal[baAdvant].height = height - portal[baAdvant].top

      portal[baDraw].width = width
      portal[baDraw].left = portal[baActing].left
      portal[baDraw].top = portal[baAdvant].bottom + 5
      portal[baDraw].height = height - portal[baDraw].top

      ~figure out the total height we need for the tab
      height = portal[baDraw].bottom
      ]]></position>

    </layout>


  <!-- basics panel
        This is the "Basics" panel shown within Hero Lab.

        The "order" attribute dictates the sequence in which the various tabs will
        be displayed. To keep everything well organized, We break the tabs up into
        four logical groupings: (1) traits and creation details, (2) equipment,
        (3) details, and (4) in-play support. Each of these groupings will have a
        three-digit value that starts with the grouping number. Since the Basics
        panel should appear first within the traits group, it has an order of "110".

        As we assign order values, We'll leave gaps in the sequence (e.g. 110, 120,
        etc.). This will allow us to easily change our minds and slip a new panel
        inbetween two existing ones as the data files evolve, without having to go
        through and re-number everything.

        We setup a suitable margin around the edges of the panel. This ensures that
        there is a little bit of spacing from the edges and eliminates the need for
        our positioning scripts to make the appropriate adjustments.

        Like with layouts, panels have a "position" script to setup the dimensions
        of child elements and orchestrate the rendering of their contents. In many
        cases, as with this panel, the default handling of panels will ensure that
        the layouts are properly rendered.

        The panel is assigned a "live" tagexpr so that its visibility can be
        controlled for different types of characters. While not really useful in the
        sample data files, this approach can be quite useful when the data files
        expand to govern creation of widely varying characters, such as vampires vs.
        ghosts vs. mortals in the World of Darkness game system.
  -->
  <panel
    id="basics"
    name="Basics"
    marginhorz="5"
    marginvert="5"
    order="110">
    <live>!HideTab.basics</live>
    <layoutref layout="basics"/>
    <position><![CDATA[
      ~get the height used by the layout and use it, as that means we scroll
      ~if necessary
      perform layout[basics].render
      height = layout[basics].height
      ]]></position>
    </panel>


  </document>
